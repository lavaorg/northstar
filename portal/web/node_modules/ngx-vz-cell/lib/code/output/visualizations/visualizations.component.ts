import {BaseVisualizationComponent} from './baseVisualization.component';
import {ChartComponent} from './chart/chart.component';
import {Visualization} from "./visualization.interface";
import {Component, ComponentFactoryResolver, ComponentRef, Input, OnChanges, SimpleChanges, ViewChild, ViewContainerRef} from "@angular/core";
import {NoneVisualization} from "./none/visualization";
import {ChartVisualization} from "./chart/visualization";
import {ValueVisualization} from "./value/visualization";
import {Options} from "../../../models/options.model";
import {ExecutionOutput} from './../../../models/output.model';
import {MapVisualization} from "./map/visualization";

// Defines the supported visualization types.
const VisualizationTypes = {
    None: "none",
    Table: "application/vnd.vz.table",
    Value: "application/vnd.vz.value",
    Map: "application/vnd.vz.map",
};

// Visualization functionality:
// This component behaves a bit differently than our other components, so read carefully to understand
// what's going on here:
//
// - A mimetype is set via the watchfield input on the component.
// - Every time an object in this component changes, angular calls the ngOnChanges function.
//   Since all we care about is change in watchField, we have an if statement to check if we're
//   looking for changes to watchField.
// - If the watchfield did change, and we can match the value to one of the registered mimetypes
//   (see the registration calls in the constructor), we clear all currently displayed components and
//   initialize the compoennt references in the object corresponding to that mimetype.
// - Rendering is done via the createComponent call.
// - Setting of local objects for our component is done by the *.instance.variableName call.
// - Mapping of our NoneVisualization is the default component. If there is no mimetype or the mimetype
//   is not recognized, then we will load this component.
//
// How to add a new visualizations?
// 1. Create an implementation of visualizationType.interface.ts. This will define the requirements for setting
//    up your component.
// 2. Add a registration line as seen below for your visualization. (see None visualization, chartvisualization,
//    and html visualization below).
// 3. Add your visualization implementation to visualizations.module.ts in the entryComponents.
//
// Note(s):
// - If you want to know more about how this works, reference:
//   http://blog.thecodecampus.de/angular-2-dynamically-render-components
//
@Component({
    selector: "visualizations",
    template: "<div #visualization ></div>",
})

export class VisualizationComponent implements OnChanges {
    @Input() watchField: string;
    @Input() code: string;
    @Input() output: ExecutionOutput;
    @Input() options: Options;

    @ViewChild("visualization", {read: ViewContainerRef})
    public visualizationComponent: ViewContainerRef;

    private visualizations: Visualization[];
    private componentFactoryResolver: ComponentFactoryResolver;

    constructor(componentFactoryResolver: ComponentFactoryResolver) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.visualizations = new Array<Visualization>();

        // Register all the supported visualizations by mime types.
        let chart = new ChartVisualization(this.componentFactoryResolver);
        this.register(VisualizationTypes.Table, chart);

        let none = new NoneVisualization(this.componentFactoryResolver);
        this.register(VisualizationTypes.None, none);

        let map = new MapVisualization(this.componentFactoryResolver);
        this.register(VisualizationTypes.Map, map);

        let numberVisualization = new ValueVisualization(this.componentFactoryResolver);
        this.register(VisualizationTypes.Value, numberVisualization);
    }

    public ngOnChanges(changes: SimpleChanges) {
        let selectedVisualization: Visualization;

        let watchFieldName = "watchField";
        let watchFieldValue = this.watchField;

        if (changes[watchFieldName]) {
            watchFieldValue = changes[watchFieldName].currentValue;
        }

        selectedVisualization = this.visualizations[watchFieldValue];
        if (!selectedVisualization) {
            selectedVisualization = this.visualizations[VisualizationTypes.None];
        }

        // Create the visualization component dynamically.
        this.visualizationComponent.clear();

        let componentReference:ComponentRef<BaseVisualizationComponent> = this.visualizationComponent.createComponent<BaseVisualizationComponent>(selectedVisualization.component);
        try {
            componentReference.instance.setOutput(this.output);
            componentReference.instance.setOptions(this.options);
        } catch (error) {
            this.output.setExecutionError(error);
            this.visualizationComponent.clear();
        }

    }

    public register(contentType: string, obj: Visualization): void {
        this.visualizations[contentType] = obj;
    }
}
