import {Injectable} from "@angular/core";
import {Observable, Observer, Subject} from "rxjs/Rx";
import {eventTypeLocalError, ReconnectingWebSocket} from "./websocket";
import {Event, EventType} from "./models/event.model";

// A selection of the standard disconnect codes for websockets. See: http://www.iana.org/assignments/websocket/websocket.xml#close-code-number-rules for more.
export const DisconnectReason = {
    NORMAL_CLOSURE: 1000,
    GOING_AWAY: 1001,
    ABNORMAL_CLOSURE: 1006,
    SERVICE_RESTART: 1012,
};

// This class is in charge of both implementing a websocket and the protocol that lives on top of it.
@Injectable()
export class EventService {

    // Event Pipe is a Subject (read/write capable observable) used for communication
    // over the web socket.
    private eventsPipe: Subject<Event>;
    private ws: ReconnectingWebSocket;
    private wsURL: string;

    // Creates an instance of the websocket if one doesn't already exist. Sets the websocket up to return events.
    constructor() {
    }

    // Set the websocket URL
    public setURL(url: string) {
      this.wsURL = url;
    }

    // Disconnect can be called to close the websocket.
    public disconnect(code: number, reason: string) {
        this.ws.close(code, reason);
    }

    // This method allows a class to write to the websocket. An event structure is required.
    public write(event: Event) {
        if (!this.wsURL) {
            throw "WebSocket URL not configured.";
        }
        if (!this.eventsPipe) {
            this.eventsPipe = this.create(this.wsURL);
        }
        this.eventsPipe.next(event);
    }


    // This method allows a class using this service to select the type of event that it wants to listen to.
    // The output of this can then be subscribed to so that events of that type can be processed.
    public observe(eventType: string): Observable<Event> {
        if (!this.wsURL) {
            throw "WebSocket URL not configured.";
        }
        if (!this.eventsPipe) {
            this.eventsPipe = this.create(this.wsURL);
        }
        return this.eventsPipe.filter((event: Event) => {
            if (event.type == eventType || event.type === EventType.InternalError) {
                // Make sure we return an actual event object.
                return true;
            }
            return false;
        });
    }

    // Create the websocket and map the proper methods to the subjects.
    private create(url: string): Subject<Event> {
        this.ws = new ReconnectingWebSocket(url);

        let observable = Observable.create(
            (obs: Observer<MessageEvent>) => {
                this.ws.onmessage = obs.next.bind(obs);
                return this.ws.close.bind(this.ws);
            }).map((response: MessageEvent): Event => {
            let event = new Event(JSON.parse(response.data));

            // If the response is for an internal error, change event type.
            if (response.type === eventTypeLocalError) {
                event.type = EventType.InternalError;
            }

            return event;
        }).share();

        let observer = {
            next: (data: Object) => {
                this.ws.send(JSON.stringify(data));
            },
        };

        return Subject.create(observer, observable);
    }
}
