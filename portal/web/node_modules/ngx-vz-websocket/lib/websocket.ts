//ws.service.ts is a wrapper for the built in websocket class.
// The built in websocket class works well for data transfer, but is unable to reconnect when it's been disconnected.
// This class recovers from such failures, creating a new websocket whenever an attempt to send without an active websocket is made.
// Also, this websocket hides the internal implementation of the websocket so that anyone subscribed to the websocket doesn't need to get
// a new instance of the websocket each time the connection is recreated.

const websocketTimeout = 250; //          stimeout in milliseconds between checks
const websocketMaxRetries = 40; // maximum checks before giving up.
export const eventTypeLocalError = "LocalError"; //Event type signifying that there was an error on the websocket.

//Inspired by: https://github.com/joewalnes/reconnecting-websocket/blob/master/reconnecting-websocket.js
export class ReconnectingWebSocket {
    private ws: WebSocket;
    private url: string;

    constructor(url: string) {
        this.url = url;
        this.connect();
    }

    // send sends data over a websocket session.
    public send(data: any): void {
        // If our websocket isn't open or connecting, set up a new one.
        if (!this.ws || (this.ws.readyState !== this.ws.OPEN && this.ws.readyState !== this.ws.CONNECTING)) {
            this.connect();
        }

        // If our websocket is connecting, give it a chance to finish.
        if (this.ws.readyState === this.ws.CONNECTING) {
            this.sendOnReconnect(websocketTimeout, websocketMaxRetries, data);
        } else if (this.ws.readyState === this.ws.OPEN) {
            try {
                this.ws.send(data);
            } catch (error) {
                this.ws.onmessage(this.getError(error));
            }
        } else {
            this.ws.onmessage(this.getError("Could not open network connection."));
            return;
        }
    }

    // Typescript doesn't have a traditional sleep. We need to use an asynchronous method instead.
    private sendOnReconnect(timeout: number, retries: number, data) {
        console.debug("WAITING.... timeout", timeout, "retries", retries);

        // Are we connected? If so, attempt to send. If we're out of retries, give up.
        if (this.ws.readyState === this.ws.OPEN) {
            try {
                this.ws.send(data);
            } catch (error) {
                this.ws.onmessage(this.getError(error));
            }
            return;
        } else if (retries === 0 || this.ws.readyState !== this.ws.CONNECTING) {
            this.ws.onmessage(this.getError("Timed out waiting for network connection."));
            return;
        }

        // Wait for timeout and then try again.
        setTimeout(() => {
            // After the timeout has been completed, call sendOnReconnect again.
            this.sendOnReconnect(timeout, retries - 1, data);
        }, timeout);
    }

    // close disconnects the websocket session.
    public close(code: number, reason: string): void {
        if (this.ws) {
            this.ws.close(code, reason);
        }
    }

    // Function to call when a message is received. Note that this is a function pointer that gets set by the websocket user.
    public onmessage = (event: MessageEvent) => {
    };

    // Function to call on an error. Note that this is a function pointer that gets set by the websocket user.
    public onerror = (event: ErrorEvent) => {
    };

    // Function to call on websocket close. Note that this is a function pointer that gets set by the websocket user.
    public onclose = (event: CloseEvent) => {
    };

    // Function to call on websocket open. Note that this is a function pointer that gets set by the websocket user.
    public onopen = (event: Event) => {
    };

    // GetError creates a message event with the error string.
    private getError(message: string): MessageEvent {
        return new MessageEvent(
            eventTypeLocalError,
            {
                data: message,
            },
        );

    }

    // Connect creates the internal websocket and connects our functions to the websocket events.
    // Note that onclose and onerror are sent to onmessage. Without this, the observable would close and need to be recreated.
    private connect() {
        this.ws = new WebSocket(this.url);
        this.ws.onopen = (event): void => {
            this.onopen(event);
        };
        this.ws.onclose = (event: CloseEvent): void => {
        };
        this.ws.onmessage = (event: MessageEvent): void => {
            this.onmessage(event);
        };
        this.ws.onerror = (event: ErrorEvent): void => {
            this.onmessage(this.getError(event.message));
        };
    }
}
